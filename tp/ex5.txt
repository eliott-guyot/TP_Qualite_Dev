Tâche 5 : Analyse conceptuelle et architecturale
1. Limites de l’implémentation actuelle du ProjectionDispatcher

L’implémentation actuelle du ProjectionDispatcher repose sur un modèle fortement simplifié dans lequel un agrégat est associé à une unique vue et à un seul gestionnaire de projection. Bien que ce modèle soit suffisant pour un cas d’usage simple, il présente plusieurs limites structurelles dans des scénarios plus réalistes.

a) Cas d’un agrégat avec plusieurs vues

Dans une architecture CQRS, il est courant qu’un même agrégat alimente plusieurs vues matérialisées répondant à des besoins différents (par exemple, une vue détaillée, une vue synthétique ou une vue orientée reporting).
L’implémentation actuelle ne permet pas de gérer efficacement ce cas, car elle suppose une relation univoque entre un agrégat et une vue. Cette contrainte limite l’évolutivité du système et conduit à des contournements tels que la duplication de logique ou l’introduction de dépendances artificielles entre projections.

b) Cas d’une vue alimentée par plusieurs agrégats

Certaines vues matérialisées nécessitent l’agrégation d’événements provenant de plusieurs agrégats distincts.
Dans ce contexte, l’implémentation actuelle ne permet pas de coordonner proprement les projections, car elle ne prend pas en compte la possibilité qu’une vue soit construite à partir de plusieurs sources d’événements. Cela complique la gestion de la cohérence des données et limite la capacité à modéliser des vues transverses.

c) Cas de multiples gestionnaires d’événements distribués

Dans un système distribué, un même événement peut déclencher plusieurs traitements indépendants :

mise à jour de différentes vues,

déclenchement d’actions techniques,

propagation vers d’autres services.

L’implémentation actuelle du ProjectionDispatcher ne permet pas de gérer efficacement :

la multiplicité des gestionnaires,

leur éventuelle distribution sur plusieurs instances ou services,

la tolérance aux pannes partielles.

Cette approche centralisée limite la scalabilité et la résilience du système.

2. Propositions d’améliorations structurelles

Pour lever les limitations identifiées, plusieurs améliorations structurelles peuvent être envisagées.

a) Découplage entre événements, projections et gestionnaires

Il est recommandé d’introduire :

une abstraction explicite représentant un ProjectionHandler,

un mécanisme de dispatch dynamique basé sur le type d’événement,

une relation de type un événement → plusieurs projections.

Cela permettrait d’associer librement un événement à plusieurs projections sans modifier le cœur du système.

b) Support des projections multi-agrégats

Afin de permettre à une vue d’être alimentée par plusieurs agrégats, il est pertinent :

d’introduire une couche de normalisation des événements,

de définir des projections capables de consommer plusieurs types d’événements,

d’adopter un modèle de projection idempotent.

Sur le plan des données, cela peut se traduire par des tables de projection enrichies ou des requêtes SQL plus complexes permettant l’agrégation de sources multiples.

c) Scalabilité et distribution des projections

Pour améliorer la scalabilité :

les projections peuvent être traitées de manière asynchrone,

les gestionnaires peuvent être répartis sur plusieurs instances,

des mécanismes de partitionnement ou de routage peuvent être introduits.

L’introduction de files de messages ou de mécanismes de consommation concurrente permettrait également d’améliorer la résilience et la capacité de montée en charge.

3. Évolution des projections et initialisation des nouvelles vues

Dans l’implémentation actuelle, l’outbox est alimentée uniquement à partir des modifications futures des agrégats.
Dans le cas où une nouvelle vue projetée serait ajoutée à partir d’un agrégat existant, cette vue ne disposerait pas des données historiques nécessaires à son initialisation correcte.

Problème identifié

Les événements passés ne seraient pas automatiquement rejoués, ce qui entraînerait une vue partiellement ou totalement vide, incohérente avec l’état réel du système.

Solution proposée

Pour garantir l’initialisation correcte d’une nouvelle vue, plusieurs approches sont possibles :

Rejeu des événements historiques à partir du journal d’événements (event replay), permettant de reconstruire la vue depuis l’origine.

Snapshot initial de l’état courant des agrégats, suivi de la consommation des événements futurs.

Migration contrôlée, combinant extraction des données existantes et activation progressive de la nouvelle projection.

Ces mécanismes doivent être conçus de manière explicite afin de garantir la cohérence, la traçabilité et la fiabilité des projections lors de l’évolution du système.